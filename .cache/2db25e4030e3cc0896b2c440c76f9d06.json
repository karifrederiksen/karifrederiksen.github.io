{"dependencies":[{"name":"E:\\dev\\Snake\\tsconfig.json","includedInParent":true,"mtime":1518205817291}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Dir;\r\n(function (Dir) {\r\n    Dir[Dir[\"Left\"] = 0] = \"Left\";\r\n    Dir[Dir[\"Up\"] = 1] = \"Up\";\r\n    Dir[Dir[\"Right\"] = 2] = \"Right\";\r\n    Dir[Dir[\"Down\"] = 3] = \"Down\";\r\n})(Dir = exports.Dir || (exports.Dir = {}));\r\nvar GameState;\r\n(function (GameState) {\r\n    GameState[GameState[\"InProgress\"] = 0] = \"InProgress\";\r\n    GameState[GameState[\"InProgressAndPaused\"] = 1] = \"InProgressAndPaused\";\r\n    GameState[GameState[\"Lost\"] = 2] = \"Lost\";\r\n    GameState[GameState[\"Won\"] = 3] = \"Won\";\r\n})(GameState = exports.GameState || (exports.GameState = {}));\r\nfunction init(args) {\r\n    var _a = args.gridSize, width = _a[0], height = _a[1];\r\n    var grid = createGrid(width, height);\r\n    return {\r\n        initArgs: args,\r\n        state: GameState.InProgress,\r\n        gridSize: args.gridSize,\r\n        grid: grid,\r\n        snake: {\r\n            direction: args.dir,\r\n            directionQueue: [args.dir],\r\n            nextDirection: args.dir,\r\n            nextNextDirection: undefined,\r\n            length: args.snakeLength,\r\n            position: args.position,\r\n        },\r\n        noms: getRandomPosition(grid, width, height),\r\n    };\r\n}\r\nexports.init = init;\r\nfunction reinit(game) {\r\n    var snake = game.snake, grid = game.grid, gridSize = game.gridSize, initArgs = game.initArgs;\r\n    var width = gridSize[0], height = gridSize[1];\r\n    for (var x = 0; x < width; x++) {\r\n        for (var y = 0; y < height; y++) {\r\n            grid[x][y] = 0;\r\n        }\r\n    }\r\n    game.noms = getRandomPosition(grid, width, height);\r\n    game.state = GameState.InProgress;\r\n    snake.direction = initArgs.dir;\r\n    snake.nextDirection = initArgs.dir;\r\n    snake.nextNextDirection = undefined;\r\n    snake.length = initArgs.snakeLength;\r\n    snake.position = initArgs.position;\r\n}\r\nexports.reinit = reinit;\r\nfunction getRandomPosition(grid, width, height) {\r\n    var x = Math.floor(Math.random() * width);\r\n    var y = Math.floor(Math.random() * height);\r\n    if (grid[x][y] > 0) {\r\n        return getRandomPosition(grid, width, height);\r\n    }\r\n    return [x, y];\r\n}\r\nfunction createGrid(width, height) {\r\n    var arr = new Array(width);\r\n    for (var x = 0; x < width; x++) {\r\n        var subArr = new Array(height);\r\n        for (var y = 0; y < height; y++) {\r\n            subArr[y] = 0;\r\n        }\r\n        arr[x] = subArr;\r\n    }\r\n    return arr;\r\n}\r\nfunction update(game) {\r\n    var nextPosition = getNextPosition(game, game.snake.nextDirection);\r\n    if (isCollision(game, nextPosition)) {\r\n        game.state = GameState.Lost;\r\n        return;\r\n    }\r\n    var x = nextPosition[0], y = nextPosition[1];\r\n    var grid = game.grid, snake = game.snake, noms = game.noms, gridSize = game.gridSize;\r\n    var width = gridSize[0], height = gridSize[1];\r\n    snake.position = [x, y];\r\n    if (x === noms[0] && y === noms[1]) {\r\n        snake.length++;\r\n        grid[x][y] = snake.length;\r\n        game.noms = getRandomPosition(grid, width, height);\r\n    }\r\n    else {\r\n        for (var x_1 = 0; x_1 < width; x_1++) {\r\n            for (var y_1 = 0; y_1 < height; y_1++) {\r\n                if (grid[x_1][y_1] > 0) {\r\n                    grid[x_1][y_1]--;\r\n                }\r\n            }\r\n        }\r\n        grid[x][y] = snake.length;\r\n    }\r\n    snake.direction = snake.nextDirection;\r\n    snake.nextDirection = snake.nextNextDirection !== undefined\r\n        ? snake.nextNextDirection\r\n        : snake.nextDirection;\r\n    snake.nextNextDirection = undefined;\r\n}\r\nexports.update = update;\r\nfunction getNextPosition(_a, direction) {\r\n    var grid = _a.grid, snake = _a.snake;\r\n    var _b = snake.position, x = _b[0], y = _b[1];\r\n    switch (direction) {\r\n        case Dir.Left:\r\n            return [x - 1, y];\r\n        case Dir.Up:\r\n            return [x, y - 1];\r\n        case Dir.Right:\r\n            return [x + 1, y];\r\n        case Dir.Down:\r\n            return [x, y + 1];\r\n    }\r\n}\r\nfunction isCollision(_a, _b) {\r\n    var grid = _a.grid, _c = _a.gridSize, width = _c[0], height = _c[1];\r\n    var x = _b[0], y = _b[1];\r\n    return x >= width\r\n        || x < 0\r\n        || y >= height\r\n        || y < 0\r\n        || grid[x][y] > 1;\r\n}\r\nfunction setDirection(_a, direction) {\r\n    var snake = _a.snake;\r\n    // Disallow 180 degree turns\r\n    if (snake.direction === snake.nextDirection) {\r\n        if (isDirectionAllowed(snake.direction, direction)) {\r\n            snake.nextDirection = direction;\r\n        }\r\n    }\r\n    else {\r\n        if (isDirectionAllowed(snake.nextDirection, direction)) {\r\n            snake.nextNextDirection = direction;\r\n        }\r\n    }\r\n}\r\nexports.setDirection = setDirection;\r\nfunction isDirectionAllowed(current, next) {\r\n    switch (current) {\r\n        case Dir.Left:\r\n            return next !== Dir.Right;\r\n        case Dir.Right:\r\n            return next !== Dir.Left;\r\n        case Dir.Up:\r\n            return next !== Dir.Down;\r\n        case Dir.Down:\r\n            return next !== Dir.Up;\r\n    }\r\n}\r\nfunction getScore(_a) {\r\n    var snake = _a.snake, initArgs = _a.initArgs;\r\n    return snake.length - initArgs.snakeLength;\r\n}\r\nexports.getScore = getScore;\r\n","map":{"version":3,"file":"core.js","sourceRoot":"","sources":["src\\snake\\core.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vec2 } from \"./vec2\"\r\nimport * as vec2 from \"./vec2\"\r\n\r\nexport const enum Dir {\r\n    Left,\r\n    Up,\r\n    Right,\r\n    Down,\r\n}\r\n\r\nexport const enum GameState {\r\n    InProgress,\r\n    InProgressAndPaused,\r\n    Lost,\r\n    Won,\r\n}\r\n\r\nexport type Grid = ReadonlyArray<number[]>\r\n\r\nexport interface Game {\r\n    readonly initArgs: InitArgs\r\n    readonly gridSize: Vec2\r\n    readonly grid: Grid,\r\n    readonly snake: Snake\r\n    noms: Vec2,\r\n    state: GameState,\r\n}\r\n\r\nexport interface Snake {\r\n    length: number,\r\n    direction: Dir,\r\n    directionQueue: [Dir] | [Dir, Dir]\r\n    nextDirection: Dir,\r\n    nextNextDirection: Dir | undefined,\r\n    position: Vec2,\r\n}\r\n\r\nexport interface InitArgs {\r\n    readonly gridSize: Vec2\r\n    readonly dir: Dir\r\n    readonly position: Vec2\r\n    readonly snakeLength: number\r\n}\r\n\r\nexport function init(args: InitArgs): Game {\r\n    const [width, height] = args.gridSize\r\n    const grid = createGrid(width, height)\r\n    return {\r\n        initArgs: args,\r\n        state: GameState.InProgress,\r\n        gridSize: args.gridSize,\r\n        grid,\r\n        snake: {\r\n            direction: args.dir,\r\n            directionQueue: [args.dir],\r\n            nextDirection: args.dir,\r\n            nextNextDirection: undefined,\r\n            length: args.snakeLength,\r\n            position: args.position,\r\n        },\r\n        noms: getRandomPosition(grid, width, height),\r\n    }\r\n}\r\n\r\nexport function reinit(game: Game): void {\r\n    const { snake, grid, gridSize, initArgs } = game\r\n    const [width, height] = gridSize\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            grid[x][y] = 0\r\n        }\r\n    }\r\n    game.noms = getRandomPosition(grid, width, height)\r\n    game.state = GameState.InProgress\r\n    snake.direction = initArgs.dir\r\n    snake.nextDirection = initArgs.dir\r\n    snake.nextNextDirection = undefined\r\n    snake.length = initArgs.snakeLength\r\n    snake.position = initArgs.position\r\n}\r\n\r\nfunction getRandomPosition(grid: Grid, width: number, height: number): Vec2 {\r\n    const x = Math.floor(Math.random() * width)\r\n    const y = Math.floor(Math.random() * height)\r\n    if (grid[x][y] > 0) {\r\n        return getRandomPosition(grid, width, height)\r\n    }\r\n    return [x, y]\r\n}\r\n\r\nfunction createGrid(width: number, height: number): Grid {\r\n    const arr = new Array<Array<number>>(width)\r\n    for (let x = 0; x < width; x++) {\r\n        const subArr = new Array<number>(height)\r\n        for (let y = 0; y < height; y++) {\r\n            subArr[y] = 0\r\n        }\r\n        arr[x] = subArr\r\n    }\r\n    return arr\r\n}\r\n\r\nexport function update(game: Game): void {\r\n    const nextPosition = getNextPosition(game, game.snake.nextDirection)\r\n    if (isCollision(game, nextPosition)) {\r\n        game.state = GameState.Lost\r\n        return\r\n    }\r\n    const [x, y] = nextPosition\r\n    const { grid, snake, noms, gridSize } = game\r\n    const [width, height] = gridSize\r\n    snake.position = [x, y]\r\n\r\n    if (x === noms[0] && y === noms[1]) {\r\n        snake.length++\r\n        grid[x][y] = snake.length\r\n        game.noms = getRandomPosition(grid, width, height)\r\n    } else {\r\n        for (let x = 0; x < width; x++) {\r\n            for (let y = 0; y < height; y++) {\r\n                if (grid[x][y] > 0) {\r\n                    grid[x][y]--\r\n                }\r\n            }\r\n        }\r\n        grid[x][y] = snake.length\r\n    }\r\n    snake.direction = snake.nextDirection\r\n    snake.nextDirection = snake.nextNextDirection !== undefined\r\n        ? snake.nextNextDirection\r\n        : snake.nextDirection\r\n    snake.nextNextDirection = undefined\r\n}\r\n\r\nfunction getNextPosition({ grid, snake }: Game, direction: Dir): Vec2 {\r\n    const [x, y] = snake.position\r\n    switch (direction) {\r\n        case Dir.Left:\r\n            return [x - 1, y]\r\n        case Dir.Up:\r\n            return [x, y - 1]\r\n        case Dir.Right:\r\n            return [x + 1, y]\r\n        case Dir.Down:\r\n            return [x, y + 1]\r\n    }\r\n}\r\n\r\nfunction isCollision({ grid, gridSize: [width, height] }: Game, [x, y]: Vec2): boolean {\r\n    return x >= width\r\n        || x < 0\r\n        || y >= height\r\n        || y < 0\r\n        || grid[x][y] > 1\r\n}\r\n\r\nexport function setDirection({ snake }: Game, direction: Dir): void {\r\n    // Disallow 180 degree turns\r\n    if (snake.direction === snake.nextDirection) {\r\n        if (isDirectionAllowed(snake.direction, direction)) {\r\n            snake.nextDirection = direction\r\n        }\r\n    } else {\r\n        if (isDirectionAllowed(snake.nextDirection, direction)) {\r\n            snake.nextNextDirection = direction\r\n        }\r\n    }\r\n}\r\n\r\nfunction isDirectionAllowed(current: Dir, next: Dir): boolean {\r\n    switch (current) {\r\n        case Dir.Left:\r\n            return next !== Dir.Right\r\n        case Dir.Right:\r\n            return next !== Dir.Left\r\n        case Dir.Up:\r\n            return next !== Dir.Down\r\n        case Dir.Down:\r\n            return next !== Dir.Up\r\n    }\r\n}\r\n\r\nexport function getScore({ snake, initArgs }: Game): number {\r\n    return snake.length - initArgs.snakeLength\r\n}"]}},"hash":"d9a747a96d1cd567e84814810bf1f652","cacheData":{"env":{}}}